/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. /home/jgulden/workspace/beautyj/src/de/gulden/util/javasource/jjt/JavadocParser.jj */
/*@egen*//**
* Parser declaration JavadocParser for JJTree / JavaCC.
*
* This is a LL(k) parser for analysing Javadoc 1.1 comments.
*
* Compilation steps:
*
* 1. JJTree: JavadocParser.jjt  -->  JavadocParser.jj
* 2. JavaCC: JavadocParser.jj   -->  JavadocParser.java
* 3. javac:  JavadocParser.java -->  JavadocParser.class
*
* Copyright (C) Jens Gulden 2001.
*
* This is licensed under the GNU General Public License (GPL).
**/

options
{
  LOOKAHEAD=1;
  JAVA_UNICODE_ESCAPE=true;
  STATIC=false;                
  ERROR_REPORTING=true;
}

PARSER_BEGIN(JavadocParser)

package de.gulden.util.javasource.jjt;

import de.gulden.util.javasource.SourceParser;
import java.io.*;

public class JavadocParser/*@bgen(jjtree)*/implements JavadocParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTJavadocParserState jjtree = new JJTJavadocParserState();

/*@egen*/

    /**
     * Parses Javadoc comments.
     * This method is reentrant.
     */
    public static Node parse(String s) throws ParseException {
        return parse(new ByteArrayInputStream(s.getBytes()));
    }

    /**
     * Parses Javadoc comments.
     * This method is reentrant.
     */
    public static Node parse(java.io.InputStream in) throws ParseException {
        Node node;
        JavadocParser parser=new JavadocParser(in);
        parser.CompilationUnit();
        node=parser.jjtree.rootNode();
        //showTree(node,System.out);
        return node;
    }

/*
    public static void showTree(Node node,PrintStream out) {
        showTree(node,out,0);
    }

    private static void showTree(Node node,PrintStream out,int depth) {
        out.println(SourceParser.repeat("  ",depth)+JavadocParserTreeConstants.jjtNodeName[node.getId()]);
        for (int i=0;i<node.jjtGetNumChildren();i++) {
            Node n=node.jjtGetChild(i);
            showTree(n,out,depth+1);
        }
    }
*/
/*
    public void jjtreeOpenNodeScope(Node n) {
        n.setStartToken(getToken(1));
    }

    public void jjtreeCloseNodeScope(Node n) {
        n.setEndToken(getToken(1));
    }
*/
}

PARSER_END(JavadocParser)



/* WHITE SPACE */

/* EOL is significant, so not part of SKIP */
SKIP :
{
  " "
| "\r"
| "\t"
}

TOKEN :
{
  < EOL: "\n" >
| < DOCSTART: "/*" ("*")+ >
| < DOCEND: "*/" >
| < STAR: "*" >

| < TAG_AUTHOR: "@author" >
| < TAG_DEPRECATED: "@deprecated" >
| < TAG_EXCEPTION: "@exception" >
| < TAG_PARAM: "@param" >
| < TAG_RETURN: "@return" >
| < TAG_SEE: "@see" >
| < TAG_SINCE: "@since" >
| < TAG_THROWS: "@throws" >
| < TAG_VERSION: "@version" >
| < TAG_ID: "@id" > // this had once been used in the original java 1.1.8 sources and is included here for compatibility

// This used to crash in version 1.0 if the comment e.g. contained "// ..." parts:
//| < WORD: ~["@","*","/"," ","\t","\r","\n"] ( ~[" ","\t","\r","\n"] )* >

| < WORD: ( ~[" ","\t","\r","\n"] )* > 
// (Leads to a warning that WORD can be matched by an empty string, but this does not seem to do harm.)
// Small problem: line-indentation gets removed when parsing, this can be relevant in rare cases when
// code-blocks are parts of the Javadoc-comment.
// This also does not allow single stars (*) inside comments, which is prevented by a workaround,
// making sure that the JavadocParser never sees single stars in the comment.

// does not work:
//| < WORD: ( ~["\r","\n"] )* > 
// Using WORD like this means actually treating a whole line as one word. This is useful to preserve indentation
// in comments, e.g. when code-blocks are part of a Javadoc-comment.

}



/*****************************************
 * The Javadoc Grammar starts here.      *
 *****************************************/

/*
 * Javadoc-comment structuring syntax follows.
 */
void CompilationUnit() :
{/*@bgen(jjtree) CompilationUnit */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
  try {
/*@egen*/
  DocStart()
  Description()
  Tags()
  DocEnd()
  <EOF>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DocStart()       :
{}
{
  <DOCSTART>
}

void DocEnd()       :
{}
{
  ( LOOKAHEAD( <EOL> ( <STAR> )* <DOCEND> )
    <EOL> )?
  ( LOOKAHEAD(1)
    <STAR> )*
  <DOCEND>
}

void Description() :
{/*@bgen(jjtree) Description */
  SimpleNode jjtn000 = new SimpleNode(JJTDESCRIPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Description */
  try {
/*@egen*/
  ( FirstLine() )?
  MoreLines()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Tags()       :
{}
{
  (
    LOOKAHEAD( <EOL> ( <STAR> )* ( <TAG_AUTHOR> | <TAG_DEPRECATED> | <TAG_EXCEPTION> | <TAG_THROWS> | <TAG_PARAM> | <TAG_RETURN> | <TAG_SINCE> | <TAG_SEE> | <TAG_VERSION> | <TAG_ID> ) )
    Tag()
  )*
}

void Line() :
{/*@bgen(jjtree) Line */
  SimpleNode jjtn000 = new SimpleNode(JJTLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Line */
  try {
/*@egen*/
  ( Word() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void FirstLine()             :
{/*@bgen(jjtree) #Line( true) */
  SimpleNode jjtn000 = new SimpleNode(JJTLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Line( true) */
  try {
/*@egen*/
  ( Word() )+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  true);
    }
  }
/*@egen*/
}

void MoreLines()       :
{}
{
  ( LOOKAHEAD( <EOL> (<STAR>)* ( <WORD> | <EOL> ) )
    NextLine() )*
}

void NextLine()       :
{}
{
  <EOL>
  (
//    LOOKAHEAD( (<STAR>)* ( <WORD> | <EOL> ) )
    LOOKAHEAD(1)
    <STAR>
  )*
  Line()
}

void Word() :
{/*@bgen(jjtree) Word */
  SimpleNode jjtn000 = new SimpleNode(JJTWORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Word */
  try {
/*@egen*/
  t =  <WORD>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.setValue(t.toString()); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ // (allow star as part of line-conent, too)
}


void Tag() :
{/*@bgen(jjtree) Tag */
  SimpleNode jjtn000 = new SimpleNode(JJTTAG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Tag */
  try {
/*@egen*/
  <EOL> ( <STAR> )*
  (
    ( t = <TAG_AUTHOR> )
  | ( t = <TAG_DEPRECATED> )
  | ( t = <TAG_EXCEPTION> TagItem() )
  | ( t = <TAG_THROWS> TagItem() )
  | ( t = <TAG_PARAM> TagItem() )
  | ( t = <TAG_RETURN> )
  | ( t = <TAG_SINCE> )
  | ( t = <TAG_SEE> )
  | ( t = <TAG_VERSION> )
  | ( t = <TAG_ID> )
  ) { jjtn000.setValue(t.toString()); }
  Line()
  MoreLines()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void TagItem() :
{/*@bgen(jjtree) TagItem */
  SimpleNode jjtn000 = new SimpleNode(JJTTAGITEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TagItem */
  try {
/*@egen*/
  Word()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}